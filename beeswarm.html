<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Accelerationism Events: Chronological Timeline</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <style>
    
    *{
        /* outline: 1px solid red; */
        box-sizing: border-box;
        
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f5f5f5;
      line-height: 1.6;
    }
    
    .visualization-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .viz-section {
      margin-bottom: 100vh;
      position: relative;
    }
    
    .viz-content {
      background-color: white;
      padding: 25px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }
    
    .sticky-viz {
      position: sticky;
      top: 50px;
      height: 600px;
      z-index: 1;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
    }
    
    h1, h2 {
      color: #333;
      margin-top: 0;
    }
    
    .tooltip {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 15px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      z-index: 10;
      max-width: 300px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }
    
    .narrative {
      padding: 30px;
      border-left: 4px solid #3498db;
      background-color: #f8f9fa;
      margin: 20px 0;
      border-radius: 0 8px 8px 0;
    }
    
    .fade-in {
      opacity: 0;
      transition: opacity 1s ease-in-out;
    }
    
    .fade-in.visible {
      opacity: 1;
    }
    
    .casualty-status {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 4px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }
    
    .casualty-status.visible {
      opacity: 1;
    }
    
    .headline {
      font-size: 28px;
      font-weight: bold;
      text-align: center;
      margin: 40px 0 20px;
      color: #2c3e50;
    }
    
    .subheadline {
      font-size: 20px;
      text-align: center;
      margin-bottom: 40px;
      color: #7f8c8d;
    }
    
    .year-label {
      text-anchor: middle;
      font-size: 14px;
      font-weight: bold;
      fill: #555;
      pointer-events: none;
    }

    @media screen and (max-width: 600px) {
    .sticky-viz {
        top: 0;
        height: 100vh; /* Full viewport height */
        border-radius: 0; /* Remove rounded corners */
        margin: 0 -10px; /* Extend to edges */
        /* padding: 10px 0; */
    }
    }

    @media screen and (max-width: 600px) {
    #visualization {
        height: 100vh; /* Use 70% of viewport height */
        min-height: 500px; /* Ensure minimum height */
    }
    }
    

  </style>
</head>
<body>
  <div class="visualization-container">
    <div class="headline">Accelerationism Events</div>
    <div class="subheadline">From Frequency to Human Impact (1995-2023)</div>
    
    <!-- Section 1: Introduction -->
    <div class="viz-section">
      <div class="viz-content">
        <h2>The Rise of Accelerationism</h2>
        <p>Accelerationism events have shown a dramatic increase over the past three decades. This visualization explores how these events have evolved over time, not just in frequency but in human impact.</p>
        <p>Scroll down to begin exploring the data...</p>
      </div>
    </div>
    
    <!-- Sticky Visualization Container -->
    <div class="sticky-viz">
      <div id="visualization"> </div>
      <div class="casualty-status" id="casualtyStatus">
        Now showing: <span id="casualtyMode">Event frequency over time</span>
      </div>
    </div>
    
    <!-- Section 2: Frequency Over Time -->
    <div class="viz-section" id="section-frequency">
      <div class="viz-content narrative fade-in">
        <h2>Event Frequency (1995-2023)</h2>
        <p>From 1995 to 2017, accelerationism events were relatively rare, with fewer than 5 events per year. Each dot represents a single event in the dataset.</p>
        <p>Notice how events begin to cluster more densely starting in 2018, showing a significant increase in frequency.</p>
      </div>
    </div>
    
    <!-- Section 3: The Turning Point -->
    <div class="viz-section" id="section-turning-point">
      <div class="viz-content narrative fade-in">
        <h2>The Turning Point (2018-2019)</h2>
        <p>2018 marked a significant turning point, with 14 recorded events - a dramatic increase from previous years.</p>
      </div>
    </div>
    
    <!-- Section 4: Recent Surge -->
    <div class="viz-section" id="section-recent">
      <div class="viz-content narrative fade-in">
        <h2>The Recent Surge (2020-2021)</h2>
        <p>In 2020, we see an unprecedented spike with 59 events, followed by 2021's peak of 85 events - the highest recorded in the dataset.</p>
        <p>After 2021, we observe some decline in 2022 (33 events) and 2023 (18 events), but numbers remain significantly higher than pre-2018 levels.</p>
      </div>
    </div>
    
    <!-- Section 5: Human Impact Transition -->
    <div class="viz-section" id="section-transition-casualties">
      <div class="viz-content narrative fade-in">
        <h2>Beyond Numbers: The Human Impact</h2>
        <p>While the frequency of events tells one story, the human impact reveals another dimension. As we transition to examining casualties, the circle size will now represent the combined number of people killed and wounded in each event.</p>
        <p>This view helps us understand which events, beyond their frequency, had the most devastating human impact.</p>
      </div>
    </div>
    
    <!-- Section 6: High-Casualty Events -->
    <div class="viz-section" id="section-high-casualties">
      <div class="viz-content narrative fade-in">
        <h2>High-Casualty Events</h2>
        <p>The largest circles represent events with the highest number of casualties. Note how some years with relatively few events still had significant human impact due to high-casualty incidents.</p>
        <p>Hover over the circles to explore the details of each event, including location, ideology, and specific casualty counts.</p>
      </div>
    </div>
    
    <!-- Section 7: Conclusion -->
    <div class="viz-section" id="section-conclusion">
      <div class="viz-content narrative fade-in">
        <h2>Understanding the Full Picture</h2>
        <p>By examining both frequency and casualties, we can see that accelerationism isn't just increasing in occurrence but also in potential for harm.</p>
        <p>This visualization helps us understand both the temporal patterns and human impact of these events, providing essential context for policymakers, researchers, and the public.</p>
      </div>
    </div>
  </div>








<!--JAVASCRIPT-->

  <script>


//------------------
//------------------
//SET-UP
//------------------
//------------------

    const isMobile = window.innerWidth < 600;


    document.addEventListener('DOMContentLoaded', function() {

 // Load the pre-processed data

      fetch('data/processed-accelerationism.json')
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then(data => {
        // Use all events without filtering
        if (data.length === 0) {
            throw new Error('No events found in the data');
        } 
        
// Initialize the visualization

          initializeVisualization(data);
        })
        .catch(error => {
          console.error('Error loading data:', error);
          document.getElementById('visualization').innerHTML = 
            `<div class="error-message">Error loading data: ${error.message}. Please check the console for details.</div>`;
        });
      
      function initializeVisualization(events) {
        // Calculate year counts
        const yearCounts = {};

        
// Setup visualization dimensions

        const margin = {
        top: isMobile ? 10 : 30, 
        right: isMobile ? 10 : 40, 
        bottom: isMobile ? 10 : 80, 
        left: isMobile ? 10 : 40
        };
        const width = 1100 - margin.left - margin.right; // Increased width
        // const height = 550 - margin.top - margin.bottom;
        const height = isMobile ? 
        (window.innerHeight - margin.top - margin.bottom) : // Mobile: 100% screen
        (550 - margin.top - margin.bottom);      
        
// Create SVG with responsive settings

        const svg = d3.select("#visualization")
        .append("svg")
        .attr("width", "100%")
        .attr("height", height + margin.top + margin.bottom)
        .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .append("g")
        .attr("transform", isMobile ? 
        `translate(${margin.left}, ${margin.top - 400})` :  // Lift up by 30px on mobile
        `translate(${margin.left}, ${margin.top})`);       // Normal position on desktop
        
        // Create scale for circle size based on casualties
        const maxCasualties = d3.max(events, d => d.incident.casualties.total) || 1;
        const radiusScale = d3.scaleSqrt()
            .domain([0, maxCasualties])
            .range([isMobile ? 8 : 4, isMobile ? 30 : 20]);
        
// Create tooltip

        const tooltip = d3.select("body").append("div")
          .attr("class", "tooltip")
          .style("opacity", 0);
        
        // Filter events with valid years
        const validEvents = events.filter(d => d.date && d.date.year);
        
        // Group events by year
        const eventsByYear = d3.group(validEvents, d => d.date.year);
        const years = Array.from(eventsByYear.keys()).sort((a, b) => a - b);
        
        // Add missing years to ensure all years in range are included
        const minYear = Math.min(...years);
        const maxYear = Math.max(...years);
        
        // Create array of all years including those without events
        const allYears = [];
        for (let y = minYear; y <= maxYear; y++) {
          allYears.push(y);
          // If this year isn't in the data, create an entry for it
          if (!years.includes(y)) {
            eventsByYear.set(y, []);
          }
        }
        
        // Sort all years
        allYears.sort((a, b) => a - b);

        
// Create year center positions - all in a single row
        const yearPositions = [];

//------------------
//------------------
//MOBILE VERSION
//------------------
//------------------

        if (isMobile) {
    // VERTICAL LAYOUT FOR MOBILE - years arranged top to bottom
    
    // Option 1: Use fixed spacing between years
    const fixedSpacing = 45; // 100 pixels between each year
    
    // Position each year with fixed spacing
    allYears.forEach((year, i) => {
        const yearEvents = eventsByYear.get(year) || [];
        const count = yearEvents.length;
        
        yearPositions.push({
            year: year,
            x: width / 2, // Center horizontally
            y: 80 + (i * fixedSpacing), // Start at 80px from top, then fixed spacing
            count: count
        });
    });

        

        } else {
        
        // Position all years in a single row
        const yearSpacing = width / (allYears.length + 1); // Add 1 for margins
        
        // Calculate positions for all years
        allYears.forEach((year, i) => {
          const yearEvents = eventsByYear.get(year) || [];
          const count = yearEvents.length;
          const sizeMultiplier = Math.sqrt(count) / 5 + 0.8;
          
          yearPositions.push({
            year: year,
            x: (i + 1) * yearSpacing, // +1 to start a bit from the left edge
            y: height / 2, // Center vertically
            count: count,
            radius: Math.max(yearSpacing / 3 * Math.min(sizeMultiplier, 1.5), 15)
          });
        });
    }
        
//------------------
//------------------
//LABELS 
//------------------
//------------------

        // Add year labels - show only some years to avoid overcrowding
        svg.selectAll(".year-label")
          .data(yearPositions)
          .enter()
          .append("text")
          .attr("class", "year-label")
          .attr("x", d => d.x)
          .attr("y", d => d.y + 100)
          .attr("text-anchor", "middle")
          .text((d, i) => {
            // Show years with spacing to avoid overlapping
            if (yearPositions.length <= 10) return d.year;
            if (yearPositions.length <= 15) return i % 2 === 0 ? d.year : '';
            if (yearPositions.length <= 25) return i % 3 === 0 ? d.year : '';
            return i % 4 === 0 ? d.year : '';
          });

//------------------
//------------------
//CIRCLES
//------------------
//------------------

        // Create a flat array of all events with their year center position
        const flatEvents = [];
        
        yearPositions.forEach(yearPosition => {
          const year = yearPosition.year;
          const yearEvents = eventsByYear.get(year) || [];
          
          yearEvents.forEach(event => {
            flatEvents.push({
              ...event,
              yearCenter: yearPosition,
              // Start positions: random across the visualization
              x: Math.random() * width,
              y: Math.random() * height
            });
          });
        });
        
        // Create event circles
        const eventCircles = svg.selectAll(".event")
          .data(flatEvents)
          .enter()
          .append("circle")
          .attr("class", "event")
          .attr("r", isMobile ? 12 : 5)
          .attr("fill", "#3498db")
          .attr("opacity", 0.8)
          .attr("stroke", "#fff")
          .attr("stroke-width", 1)
          .attr("cx", d => d.x)
          .attr("cy", d => d.y)
          .on("mouseover", function(event, d) {
            // Highlight circle on hover
            d3.select(this)
              .transition()
              .duration(200)
              .attr("stroke-width", 2)
              .attr("opacity", 1);

//------------------
//------------------
//TOOLTIP
//------------------
//------------------
            
            // Format the date
            const dateStr = d.date.full || `${d.date.year || ''}`;
            
            // Show tooltip with the new data structure
            tooltip.transition()
              .duration(200)
              .style("opacity", 0.9);
            
            // Build tooltip content from available data
            let tooltipContent = '';
            
            if (dateStr) tooltipContent += `<strong>Date:</strong> ${dateStr}<br>`;
            if (d.incident.location.formatted) tooltipContent += `<strong>Location:</strong> ${d.incident.location.formatted}<br>`;
            // if (d.ideology.affiliation) tooltipContent += `<strong>Ideology:</strong> ${d.ideology.affiliation}<br>`;
            // if (d.incident.method) tooltipContent += `<strong>Method:</strong> ${d.incident.method}<br>`;
            
            tooltipContent += `<strong>Casualties:</strong> ${d.incident.casualties.killed} killed, ${d.incident.casualties.injured} injured<br>`;
            
            if (d.perpetrator.name) tooltipContent += `<strong>Perpetrator:</strong> ${d.perpetrator.name}<br>`;
            // if (d.narrative) tooltipContent += `<strong>Details:</strong> ${d.narrative}`;
            
            tooltip.html(tooltipContent)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 15) + "px");
          })
          .on("mouseout", function() {
            // Reset circle appearance
            d3.select(this)
              .transition()
              .duration(200)
              .attr("stroke-width", 1)
              .attr("opacity", 0.8);
            
            // Hide tooltip
            tooltip.transition()
              .duration(500)
              .style("opacity", 0);
          });
        
//------------------
//------------------
//FORCE SIMULATION
//------------------
//------------------

        // Create improved force simulation
        const simulation = d3.forceSimulation(flatEvents)
        .alphaDecay(0.01)
        .velocityDecay(isMobile ? 0.4 : 0.3) // More friction on mobile
        .force("x", d3.forceX(d => d.yearCenter.x).strength(isMobile ? 0.1 : 0.4)) // Less horizontal constraint on mobile
        .force("y", d3.forceY(d => d.yearCenter.y).strength(0.5))
        .force("charge", d3.forceManyBody().strength(isMobile ? -40 : -20)) // More repulsion on mobile
        .force("collide", d3.forceCollide(isMobile ? 15 : 5).strength(isMobile ? 0.5 : 0.5)) // Larger collision area on mobile
                .on("tick", () => {
            eventCircles
              .attr("cx", d => d.x)
              .attr("cy", d => d.y);
          })
          .stop();
        
        // Track scrolling state for smoother transitions
        let inCasualtyView = false;
        let inHighCasualtyFocus = false;
        let hasStartedAnimation = false;
        
        // Create an observer for the visualization container

//------------------
//------------------
//ANIMATION TRIGGER
//------------------
//------------------

        const visualizationObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            // If the visualization comes into view and animation hasn't started yet
            if (entry.isIntersecting && !hasStartedAnimation) {
              console.log("Visualization in view, starting animation");
              startAnimation();
              
              // Optional: Stop observing after animation starts
              visualizationObserver.unobserve(entry.target);
            }
          });
        }, {
          threshold: 0.2 // Start when 20% of the visualization is visible
        });

        // Start observing the visualization container
        visualizationObserver.observe(document.querySelector('.sticky-viz'));
        
        
        
        
        // Improved animation function
        function startAnimation() {
          if (hasStartedAnimation) return;
          hasStartedAnimation = true;
          
          // Calculate cluster radii based on event count
          const yearEventCounts = {};
          flatEvents.forEach(e => {
            yearEventCounts[e.date.year] = (yearEventCounts[e.date.year] || 0) + 1;
          });
          
          // Animate circles to their year centers with better distribution
          eventCircles.transition()
            .duration(1200)
            .delay((d, i) => i % 10 * 15)
            .attrTween("cx", function(d) {
              const startX = +d3.select(this).attr("cx");
              
              // Smaller horizontal spread
              const targetX = d.yearCenter.x + (Math.random() - 0.5) * 15;
              
              return d3.interpolate(startX, targetX);
            })
            .attrTween("cx", function(d) {
                const startX = +d3.select(this).attr("cx");
                
                // On mobile, much wider horizontal spread since dots are stacked vertically
                const horizontalSpread = isMobile ? width * 0.6 : 15;
                const targetX = d.yearCenter.x + (Math.random() - 0.5) * horizontalSpread;
                
                return d3.interpolate(startX, targetX);
                })
            .on("end", () => {
              // Start force simulation
              simulation.alpha(0.9).restart();
              
              // Schedule a restart for better arrangement
              setTimeout(() => {
                simulation.alpha(0.3).restart();
              }, 2000);
            });
        }

        
        
//------------------
//------------------
//SCROLLY
//------------------
//------------------
        
        
        // SCROLLYTELLING FUNCTIONALITY
        // Set up Intersection Observer for scrollytelling
        const sections = document.querySelectorAll('.viz-section');
        const narratives = document.querySelectorAll('.narrative');
        const casualtyStatus = document.getElementById('casualtyStatus');
        const casualtyModeText = document.getElementById('casualtyMode');
        
        let currentSection = 0;
        
        const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const section = entry.target;
              const sectionIndex = Array.from(sections).indexOf(section);
              
              if (sectionIndex !== currentSection) {
                currentSection = sectionIndex;
                
                // Show the corresponding narrative
                narratives.forEach((narrative, i) => {
                  if (i === sectionIndex - 1) {
                    narrative.classList.add('visible');
                  }
                });
                
                // Handle visualization transitions
                handleSectionTransition(sectionIndex);
              }
            }
          });
        }, { threshold: 0.3 });
        
        // Observe all sections
        sections.forEach(section => {
          observer.observe(section);
        });
        
        // Function to handle visualization transitions
        function handleSectionTransition(sectionIndex) {
          // Start animation if needed
            if (!hasStartedAnimation) {
            console.log("Starting animation from section transition");
            startAnimation();
          }
          
          // Always restart simulation for more movement
          simulation.alpha(0.2).restart();
          
          if (sectionIndex <= 4) { // Sections 0-4: frequency view
            if (inCasualtyView) {
            // Reset to frequency view
            eventCircles
                .interrupt()
                .transition()
                .duration(300)
                .attr("r", isMobile ? 12 : 5) // Bigger dots on mobile
                .attr("fill", "#3498db");
            
            // Update collision force
            simulation.force("collide", d3.forceCollide(isMobile ? 10 : 6).strength(0.9));
            inCasualtyView = false;
            }
            
            if (inHighCasualtyFocus) {
              eventCircles
                .interrupt()
                .transition()
                .duration(300)
                .style("opacity", 0.8)
                .attr("stroke-width", 1);
              inHighCasualtyFocus = false;
            }
            
            casualtyStatus.classList.remove('visible');
            casualtyModeText.textContent = 'Event frequency over time';
          } 
          else if (sectionIndex === 5) { // Section 5: transition to casualties
            // Transition to casualty view using the new data structure
            eventCircles
              .interrupt()
              .transition()
              .duration(300)
              .attr("r", d => radiusScale(d.incident.casualties.total))
              .attr("fill", d => {
                // Color based on casualty severity
                if (d.incident.casualties.killed > 5) return '#e74c3c';
                if (d.incident.casualties.killed > 0) return '#e67e22';
                if (d.incident.casualties.killed === 0 && d.incident.casualties.injured > 0) return '#f1c40f';
                return '#3498db';
              });
            
            // Update collision force
            simulation.force("collide", d3.forceCollide(d => radiusScale(d.incident.casualties.total) + 1).strength(0.9));
            inCasualtyView = true;
            
            if (inHighCasualtyFocus) {
              eventCircles
                .interrupt()
                .transition()
                .duration(300)
                .style("opacity", 0.8)
                .attr("stroke-width", 1);
              inHighCasualtyFocus = false;
            }
            
            casualtyStatus.classList.add('visible');
            casualtyModeText.textContent = 'Human impact (circle size = total casualties)';
          }
          else if (sectionIndex === 6) { // Section 6: high casualty focus
            if (!inCasualtyView) {
              // First transition to casualty view if coming from frequency view
              eventCircles
                .interrupt()
                .transition()
                .duration(300)
                .attr("r", d => radiusScale(d.incident.casualties.total))
                .attr("fill", d => {
                  if (d.incident.casualties.killed > 10) return '#e74c3c';
                  if (d.incident.casualties.killed > 0) return '#e67e22';
                  if (d.incident.casualties.killed === 0 && d.incident.casualties.injured > 0) return '#f1c40f';
                  return '#3498db';
                });
              
              simulation.force("collide", d3.forceCollide(d => radiusScale(d.incident.casualties.total) + 1).strength(0.9));
              inCasualtyView = true;
            }
            
            // Highlight high-casualty events using the new data structure
            eventCircles
              .interrupt()
              .transition()
              .duration(300)
              .style("opacity", d => (d.incident.casualties.total > 10) ? 1 : 0.3)
              .attr("stroke-width", d => (d.incident.casualties.total > 10) ? 2 : 1);
            
            inHighCasualtyFocus = true;
            casualtyStatus.classList.add('visible');
            casualtyModeText.textContent = 'Focus on high-casualty events';
          }
          else { // Section 7+: conclusion, show all again
            if (!inCasualtyView) {
              // First transition to casualty view if coming from frequency view
              eventCircles
                .interrupt()
                .transition()
                .duration(300)
                .attr("r", d => radiusScale(d.incident.casualties.total))
                .attr("fill", d => {
                  if (d.incident.casualties.killed > 10) return '#e74c3c';
                  if (d.incident.casualties.killed > 0) return '#e67e22';
                  if (d.incident.casualties.killed === 0 && d.incident.casualties.injured > 0) return '#f1c40f';
                  return '#3498db';
                });
              
              simulation.force("collide", d3.forceCollide(d => radiusScale(d.incident.casualties.total) + 1).strength(0.9));
              inCasualtyView = true;
            }
            
            eventCircles
              .interrupt()
              .transition()
              .duration(300)
              .style("opacity", 0.8)
              .attr("stroke-width", 1);
            
            inHighCasualtyFocus = false;
            casualtyStatus.classList.add('visible');
            casualtyModeText.textContent = 'Human impact (circle size = total casualties)';
          }
        }
        
        // Initially make the status hidden
        casualtyStatus.classList.remove('visible');
        
        // Set up fade-in animations for narrative sections
        const fadeElements = document.querySelectorAll('.fade-in');
        
        const fadeObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              entry.target.classList.add('visible');
              fadeObserver.unobserve(entry.target);
            }
          });
        }, { threshold: 0.3 });
        
        fadeElements.forEach(element => {
          fadeObserver.observe(element);
        });
        
        // Add scroll event handler for fast scrolling scenarios
        window.addEventListener('scroll', function() {
          // Keep simulation active during scrolling
          if (hasStartedAnimation) {
            simulation.alpha(0.1).restart();
          }
        }, { passive: true });
      }
    });
  </script>
</body>
</html>